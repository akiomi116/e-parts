<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>BOMビューア</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/svg-pan-zoom@3.6.1/dist/svg-pan-zoom.min.js"></script>
  <style>
    html, body {
      height: 100%;
      overflow: hidden;
    }
    .main-container {
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    .content-row {
      flex-grow: 1;
      display: grid;
      grid-template-columns: 1fr 2fr; /* 左右の比率（可変） */
      grid-template-rows: 100%;
      overflow: hidden;
    }
    /* 左側（部品表）をドラッグで可変にする */
    .scrollable-col {
      resize: horizontal;
      overflow-y: auto;
      overflow-x: hidden;
      min-width: 250px;
      max-width: 80vw;
      border-right: 3px solid #ddd;
    }
    .svg-container, .tab-content, .tab-pane {
      height: 100%;
      width: 100%;
    }
    .svg-container svg {
      width: 100%;
      height: 100%;
      touch-action: none;
    }
    #bom-table tbody tr {
      cursor: pointer;
    }
    #bom-table tbody tr.highlight td,
    #bom-table.table-hover tbody tr.highlight:hover td {
        background-color: #0d6efd !important;
        color: white !important;
        font-weight: bold;
    }
    #bom-table tbody tr.not-found td {
        background-color: #ffc107 !important;
        transition: background-color 0.2s ease-in-out;
    }
    g.svg-highlight text {
      fill: red !important;
      font-weight: bold;
    }
    g.svg-highlight path,
    g.svg-highlight rect,
    g.svg-highlight circle,
    g.svg-highlight polygon {
      filter: drop-shadow(0px 0px 2px red) drop-shadow(0px 0px 2px red);
      -webkit-filter: drop-shadow(0px 0px 2px red) drop-shadow(0px 0px 2px red);
      stroke: red !important;
      stroke-width: 1px;
    }
  </style>
</head>
<body>
  <div class="main-container p-3">
    <h1>BOM + 回路図 / PCB ビューア</h1>
    <div class="content-row">
      <div class="scrollable-col p-2">
        <table id="bom-table" class="table table-striped table-hover">
          <thead>
            <tr><th>Ref</th><th>Value</th><th>Footprint</th><th>MPN</th><th>Qty</th></tr>
          </thead>
          <tbody>
            {% for line in lines %}
            <tr data-ref="{{ line.reference }}">
              <td>{{ line.reference }}</td>
              <td>{{ line.value }}</td>
              <td>{{ line.footprint }}</td>
              <td>{{ line.mpn }}</td>
              <td>{{ line.quantity }}</td>
            </tr>
            {% endfor %}
          </tbody>
        </table>
      </div>
      <div class="d-flex flex-column">
        <div class="alert alert-info py-1 px-2 small">
          <strong>操作ガイド:</strong> 部品をクリックすると連動してハイライトされます。より正確に反応させるには、<code>R1</code>や<code>C1</code>などの**部品番号**の近くをクリックしてください。
        </div>
        <ul class="nav nav-tabs">
          <li class="nav-item">
            <button class="nav-link active" data-bs-toggle="tab" data-bs-target="#schematic">回路図</button>
          </li>
          <li class="nav-item">
            <button class="nav-link" data-bs-toggle="tab" data-bs-target="#pcb">基板図</button>
          </li>
        </ul>
        <div class="tab-content border border-top-0 flex-grow-1">
          <div class="tab-pane fade show active" id="schematic">
            <div id="schematic-container" class="svg-container"></div>
          </div>
          <div class="tab-pane fade" id="pcb">
            <div id="pcb-container" class="svg-container"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
window.addEventListener('DOMContentLoaded', function() {
  let activeRef = null;
  const schematicContainer = document.getElementById('schematic-container');
  const pcbContainer = document.getElementById('pcb-container');

  function highlightInSvg(svgElement, ref) {
    if (!svgElement) return false;
    let found = false;
    svgElement.querySelectorAll('g.svg-highlight').forEach(g => g.classList.remove('svg-highlight'));
    if (ref) {
      svgElement.querySelectorAll('g.stroked-text').forEach(strokedTextGroup => {
        const descElement = strokedTextGroup.querySelector('desc');
        if (descElement && descElement.textContent.trim() === ref) {
          strokedTextGroup.classList.add('svg-highlight');
          found = true;
        }
      });
    }
    return found;
  }

  // 🌀 画面中央へスムーズにパン
  function smoothPanTo(svgElement, bbox) {
    if (!svgElement || !svgElement.panZoomInstance) return;

    const panZoom = svgElement.panZoomInstance;
    const sizes = panZoom.getSizes();
    const zoom = sizes.realZoom;

    // BBoxの中心座標を計算
    const cx = bbox.x + bbox.width / 2;
    const cy = bbox.y + bbox.height / 2;

    // 中央に表示するための目標Pan座標を計算
    const targetPan = {
      x: (sizes.width / 2) - (cx * zoom),
      y: (sizes.height / 2) - (cy * zoom)
    };

    const currentPan = panZoom.getPan();
    const duration = 300; // アニメーション時間 (ms)
    let startTime = null;

    function animate(timestamp) {
      if (!startTime) startTime = timestamp;
      // 0から1への進捗を計算
      const progress = Math.min((timestamp - startTime) / duration, 1);
      // イージング関数（ease-out）
      const easeProgress = 1 - Math.pow(1 - progress, 3);

      // 中間Pan座標を計算
      const animatedPan = {
        x: currentPan.x + (targetPan.x - currentPan.x) * easeProgress,
        y: currentPan.y + (targetPan.y - currentPan.y) * easeProgress
      };

      panZoom.pan(animatedPan);

      if (progress < 1) {
        requestAnimationFrame(animate);
      }
    }

    requestAnimationFrame(animate);
  }

  function highlightByRef(ref) {
    activeRef = (ref === activeRef) ? null : ref;

    document.querySelectorAll("#bom-table tr[data-ref]").forEach(row => {
      row.classList.remove('not-found');
      row.classList.toggle("highlight", row.dataset.ref === activeRef);
    });

    const foundInSchematic = highlightInSvg(schematicContainer.querySelector('svg'), activeRef);
    const foundInPcb = highlightInSvg(pcbContainer.querySelector('svg'), activeRef);

    if (activeRef && !foundInSchematic && !foundInPcb) {
      const row = document.querySelector(`#bom-table tr[data-ref="${activeRef}"]`);
      if (row) {
        row.classList.add('not-found');
        row.classList.remove('highlight');
        setTimeout(() => {
          if(row.dataset.ref === activeRef) row.classList.add('highlight');
          row.classList.remove('not-found');
        }, 1000);
      }
    }

    // ✅ ズーム固定、スムーズパンのみ
    const activeSvg = foundInSchematic ? schematicContainer.querySelector('svg') :
                     foundInPcb ? pcbContainer.querySelector('svg') : null;
    if (activeSvg && activeRef) {
      const highlightedGroup = activeSvg.querySelector('g.svg-highlight');
      if (highlightedGroup) {
        const bbox = highlightedGroup.getBBox();
        smoothPanTo(activeSvg, bbox);
      }
    }
  }

  document.querySelectorAll("#bom-table tr[data-ref]").forEach(row => {
    row.addEventListener("click", () => highlightByRef(row.dataset.ref));
  });

  function initPanZoom(container, svgElement) {
    if (container.panZoomInitialized) return;

    const panZoomInstance = svgPanZoom(svgElement, {
      zoomEnabled: true,
      controlIconsEnabled: true,
      fit: true,
      center: true,
      minZoom: 0.1,
      maxZoom: 50,
      doubleClickZoomEnabled: false
    });

    // Custom click vs. drag/pan detection to avoid conflicts with the library
    let mouseDownPos = null;
    let isPanning = false;
    svgElement.addEventListener('mousedown', (e) => {
      mouseDownPos = {x: e.clientX, y: e.clientY};
      isPanning = false; // Reset panning flag
    });

    svgElement.addEventListener('mousemove', (e) => {
        // If mouse moves more than a few pixels after mousedown, it's a pan
        if (mouseDownPos && !isPanning) {
            const dx = e.clientX - mouseDownPos.x;
            const dy = e.clientY - mouseDownPos.y;
            if (Math.sqrt(dx*dx + dy*dy) > 5) {
                isPanning = true;
            }
        }
    });

    svgElement.addEventListener('mouseup', (e) => {
      if (isPanning) {
        mouseDownPos = null;
        return;
      }

      const target = e.target;
      let ref = null;

      // Strategy 1: DOM traversal
      const parentGroup = target.closest('g');
      if (parentGroup) {
        let descElement = parentGroup.querySelector('desc');
        if (!descElement) {
          const strokedTextGroup = parentGroup.querySelector('g.stroked-text');
          if (strokedTextGroup) {
            descElement = strokedTextGroup.querySelector('desc');
          }
        }
        if (descElement) {
          ref = descElement.textContent.trim();
        }
      }

      // Strategy 2: Proximity search fallback
      if (!ref) {
        const clickBBox = e.target.getBBox();
        const clickPoint = {
          x: clickBBox.x + clickBBox.width / 2,
          y: clickBBox.y + clickBBox.height / 2
        };
        let closest = { ref: null, distance: Infinity };

        svgElement.querySelectorAll('g.stroked-text').forEach(strokedTextGroup => {
          const descElement = strokedTextGroup.querySelector('desc');
          if (descElement) {
            const candidateRef = descElement.textContent.trim();
            const candidateBBox = strokedTextGroup.getBBox();
            const candidatePoint = {
              x: candidateBBox.x + candidateBBox.width / 2,
              y: candidateBBox.y + candidateBBox.height / 2
            };
            const dx = clickPoint.x - candidatePoint.x;
            const dy = clickPoint.y - candidatePoint.y;
            const distance = Math.sqrt(dx*dx + dy*dy);
            if (distance < closest.distance) {
              closest.distance = distance;
              closest.ref = candidateRef;
            }
          }
        });

        if (closest.distance < 30) {
          ref = closest.ref;
        }
      }

      // Final validation and highlight
      if (ref && !document.querySelector(`#bom-table tr[data-ref="${ref}"]`)) {
        ref = null;
      }

      highlightByRef(ref);

      if (activeRef) {
        const bomRow = document.querySelector(`#bom-table tr[data-ref="${activeRef}"]`);
        if (bomRow) {
          bomRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
      }
      
      mouseDownPos = null;
    });


    svgElement.panZoomInstance = panZoomInstance;
    container.panZoomInitialized = true;

    // ✅ パネルリサイズ時にSVGのサイズを更新するためのObserver
    if (window.ResizeObserver) {
      const resizeObserver = new ResizeObserver(() => {
        panZoomInstance.resize();
      });
      resizeObserver.observe(container);
    }
  }

  async function loadAndInitSvg(container, url, isInitiallyActive) {
    try {
      const response = await fetch(url);
      if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      const svgText = await response.text();
      container.innerHTML = svgText;
      const svgElement = container.querySelector('svg');
      if (!svgElement) throw new Error('SVG element not found.');

      container.svgElement = svgElement;
      if (isInitiallyActive) {
        initPanZoom(container, svgElement);
      } else {
        container.panZoomInitialized = false;
      }

      highlightByRef(null);
      checkMissingRefs(svgElement);

    } catch (e) {
      console.error(`Failed to load SVG from ${url}:`, e);
      container.innerHTML = `<div class="p-3 text-danger">Error loading SVG: ${e.message}</div>`;
    }
  }

  function checkMissingRefs(svgElement) {
    if (!svgElement) return;
    document.querySelectorAll("#bom-table tr[data-ref]").forEach(row => {
      const ref = row.dataset.ref;
      const found = [...svgElement.querySelectorAll('desc')].some(d => d.textContent.trim() === ref);
      if (!found) {
        row.classList.add('not-found');
      }
    });
  }

  // SVGロード
  loadAndInitSvg(schematicContainer, "{{ url_for('static', filename=schematic_svg) }}", true);
  loadAndInitSvg(pcbContainer, "{{ url_for('static', filename=pcb_svg) }}", false);

  // ✅ ウィンドウリサイズ時にSVGのサイズを更新
  window.addEventListener('resize', () => {
    [schematicContainer, pcbContainer].forEach(container => {
      const svg = container.svgElement;
      if (svg && svg.panZoomInstance) {
        // ビューをリセットせず、内部のサイズ情報のみ更新
        svg.panZoomInstance.resize();
      }
    });
  });

  // タブ切替時にも補正
  document.querySelectorAll('button[data-bs-toggle="tab"]').forEach(tab => {
    tab.addEventListener('shown.bs.tab', function (event) {
      const paneId = event.target.getAttribute('data-bs-target');
      const container = document.querySelector(paneId + '-container');
      const svgElement = container.svgElement;
      if (svgElement) {
        if (!container.panZoomInitialized) {
          initPanZoom(container, svgElement);
        }
        if (svgElement.panZoomInstance) {
          svgElement.panZoomInstance.resize();
          svgElement.panZoomInstance.center();
          svgElement.panZoomInstance.fit();
        }
      }
    });
  });
});
</script>
</body>
</html>
